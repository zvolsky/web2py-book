## Řízení přístupu
``Auth``:inxx ``Access Control``:inxx ``RBAC``:inxx ``DAC``:inxx ``MAC``:inxx

Web2py má silný a uživatelsky přizpůsobitelný mechanismus pro řízení přístupu podle role (Role Based Access Control mechanism (RBAC)).

Definice z Wikipedie:

"Role-Based Access Control (RBAC) je postup, jak omezit přístup k systému jen na autorizované uživatele. Je to novější alternativa k 'mandatory (zmocnění, oprávnění) access control (MAC)' a k 'discretionary (výběrový) access control (DAC)'. RBAC se někdy také nazývá "bezpečnost, odvozená z role (úlohy)".

RBAC je technologie řízení přístupu, která je neutrální vzhledem k zásadám politiky a dostatečně flexibilní, aby implementovala DAC i MAC řízení přístupu. Z opačného pohledu MAC může simulovat RBAC, za určitého omezení grafu rolí.

Před vývojem RBAC byly MAC a DAC považovány za jediné možné modely řízení přístupu s tím, že pokud model není MAC mělo se za to, že je vždy DAC, a naopak. Koncem 90-tých let bylo ukázáno, že RBAC model nespadá do žádné z těchto kategorií.

Oprávnění vykonávat nějaké operace se přiřadí konkrétním rolím. Uživatelům se přiřadí jednotlivé role a díky těmto rolím získají oprávnění vykonávat konkrétní funkce v systému. Na rozdíl od context-based řízení přístupu (CBAC), RBAC nebere zřetel na context zprávy (zadání příkazu) jako např. na použitý způsob připojení.

Tím, že se uživatelům nepřiřadí oprávnění vykonávat činnosti přímo, ale až pomocí role (nebo rolí), správa jednotlivých uživatelů se podstatně zjednoduší a redukuje se na zařazení uživatele do rolí. Tím je mnohem jednodušší přidat nového uživatele nebo upravit práva po změně jeho zařazení v organizaci.

RBAC se liší od seznamů řízení přístupu (access control lists - ACLs), které používá tradiční DAC tím, že přiřazuje oprávnění ke konkrétním operacím, které mají svůj jasně daný význam (ve firmě, v organizaci, ..), místo aby oprávnění přiřazoval k datovým objektům nízké úrovně. Například DAC povolí nebo zakáže zápis do nějakého jednotlivého systémového souboru, kdežto RBAC povoluje určitý postup modifikace takového souboru."


Web2py třída, která implementuje RBAC, se nazývá **Auth**.

**Auth** potřebuje (a také si definuje) následující tabulky:
- ``auth_user`` uchovává jméno uživatele, emailovou adresu, heslo a stav (očekává potvrzení registrace (registration pending), akceptován, blokován)
- ``auth_group`` ukládá skupiny (role, z hlediska RBAC), do nichž je možné řadit uživatele. Defaultně je vytvořena individuální skupina pro každého uživatele, ale lze vytvářet další skupiny a uživatele zařadit do více z nich.
- ``auth_membership`` propojuje vazbou m:n (mnoho:mnoho) uživatele (users) a skupiny (groups resp. roles).
- ``auth_permission`` propojuje skupiny (groups) a oprávnění (permissions). Oprávnění (permission) je určeno svým jménem a volitelně může být zadána i tabulka a konkrétní záznam. Tedy např. členům určité skupiny může být dáno oprávnění aktualizovat určitý záznam některé tabulky.
- ``auth_event`` loguje změny v ostatních tabulkách a úspěšné přístupy k objektům RBAC.
- ``auth_cas`` je používána při použití Web2py jako jednotné autentikační služby (central authentication service, CAS). Každá Web2py aplikace totiž může pracovat jako poskytovatel CAS služby (CAS provider) a také případně může být klientem jiné CAS služby (CAS consumer).

Celé schéma je graficky vyznačeno na tomto obrázku:

[[image @///image/schema_auth.png center 300px]]



V principu nejsou omezena jména skupin (rolí) ani jména oprávnění; vývojář je může vytvářet tak, aby namodeloval role a oprávnění v organizaci. Poté, co jsou vytvořeny, Web2py poskytuje rozhraní (API), pomocí kterého lze zjistit, zda je uživatel přihlášen, zda patří do zadané skupiny a zda (díky zařazení do skupiny) má oprávnění k určité akci.

Web2py také nabízí vývojáři dekorátory k omezení přístupu k akcím aplikace podle loginu (přihlášení uživatele), členství ve skupině a oprávnění.

Web2py také přímo rozumí některým speciálním oprávněním, a sice těm, jejichž jména odpovídají CRUD metodám (create, read, update, delete) a může je zajistit automaticky i bez použití dekorátorů.

V této kapitole probereme jednotlivé části RBAC.

### Autentikace

Než lze začít RBAC využívat, je potřeba identifikovat uživatele. Znamená to, že se uživatel musí zarregistrovat (nebo být zaregistrován) a pak přihlásit.

**Auth** poskytuje různé metody přihlašování. Defaultní metoda spočívá v identifikaci uživatele pomocí tabulky ``auth_user``.
Alternativně je možné nechat přihlašovat uživatele proti autentikačnímu systému třetí strany jako je Google, PAM, LDAP, Facebook, LinkedIn, Dropbox, OpenID, OAuth, apod..

Aby vůbec bylo možné začít ``Auth`` používat, potřebujete alespoň přidat do modelu tento kód, který je také součástí aplikace "welcome" a tím pádem i aplikací nově vytvořených ve webovém rozhraní a který předpokládá existenci připojení do databáze jako proměnnou ``db``:
``
from gluon.tools import Auth
auth = Auth(db)
auth.define_tables(username=False, signature=False)
``:code

Web2py defaultně používá k příihlášení email uživatele. Jestliže místo toho chcete použít jméno uživatele, nastavte ``auth.define_tables(username=True)``.

Nastavení ``signature=True`` přidá do auth tabulek informaci o uživateli a čase, takže lze sledovat změny.

Auth má volitelný argument ``secure=True``, který vynutí, že autentikační stránky použijí protokol HTTPS. ``https``:inxx

Auth defaultně chrání přihlášení proti útokům cross-site request forgeries (CSRF). To zajišťuje standardní Web2py ochrana proti CSRF, implementovaná ve formulářích, generovaných v rámci session. Za určitých okolností by ale mohlo být nepřijatelné zpomalení vytvořením sessiony pro login, ověření nebo resetování. DOS útoky (přetížení nedostatečně rychlého serveru extrémním množstvím požadavků) jsou teoreticky možné. CSRF ochranu můžete pro Auth formuláře potlačit:
``Auth = Auth(..., csrf_prevention = False)``:code 
Poznamenenjme, že se to k zabránění zpomalení vlivem session na zatížených stránkách nedoporučuje, vzhledem k tím zanesenému bezpečnostnímu riziku. Místo toho si přečtěte v kapitole o Deployment doporučení, jak redukovat zatížení, které způsobuje session.
-------
Pole ``password`` tabulky ``db.auth_user`` má defaultně validátor ``CRYPT``, který vyžaduje argument ``hmac_key``. V některých Web2py aplikacích můžete vidět použití tohoto argumentu, který je předán konstruktoru Auth: ``hmac_key = Auth.get_or_create_key()``. Tato funkce přečte HMAC klíč ze souboru "private/auth.key". Pokud soubor neexistuje, vytvoří se náhodný klíč ``hmac_key``. Jestliže by více aplikací sdílelo společnou auth databázi, musíte zajistit, aby také používaly tentýž ``hmac_key``. Ale pro nové aplikace už to není nutné - hesla jsou zakódována náhodně modifikovaným klíčem [are salted with an individual random salt].
-------


Jestliže by více aplikací sdílelo společnou auth databázi, budete potřebovat zakázat migrace: ``auth.define_tables(migrate=False)``.

Ke zveřejnění **Auth** musíte také mít akci user() v kontroléru (typicky v "default.py"):
``
def user(): return dict(form=auth())
``:code

-------
Ve vzorové aplikaci ('welcome', z níž se odvodí nová aplikace, je-li vytvořena ve webovém administračním rozhraní) jsou objekt ``auth`` a akce ``user`` již definovány.
-------

Web2py rovněž obsahuje šablonu (view) "welcome/views/default/user.html" pro renderování této akce, která vypadá takto:
``
{{extend 'layout.html'}}
<h2>{{=T( request.args(0).replace('_',' ').capitalize() )}}</h2>
<div id="web2py_user_form">
  {{=form}}
  {{if request.args(0)=='login':}}
    {{if not 'register' in auth.settings.actions_disabled:}}
      <br/><a href="{{=URL(args='register')}}">register</a>
    {{pass}}
    {{if not 'request_reset_password' in auth.settings.actions_disabled:}}
      <br/>
      <a href="{{=URL(args='request_reset_password')}}">lost password</a>
    {{pass}}
  {{pass}}
</div>
``:code

Poznamenejme, že akce user() standardním způsobem zobrazuje formulář (``form``) a tedy tento formulář můžete přizpůsobit obvyklým postupem pro uživatelské úpravy formulářů. Jen je třeba dát pozor na to, že formulář, který je pro ``form=auth()`` zobrazován, závisí na ``request.args(0)``; takže např. když chcete nahradit defaultní ``auth()`` login (přihlašovací formulář) nějakým vaším vlastním, budete v šabloně nejspíše potřebovat příkaz ``if``, např.:
``
{{if request.args(0)=='login':}}...změněný login form...{{pass}}
``:code

``auth.impersonate``:inxx ``auth.is_impersonating``:inxx

Kontrolér + akce default/user zveřejňuje tyto url:
``
http://.../[app]/default/user/register
http://.../[app]/default/user/login
http://.../[app]/default/user/logout
http://.../[app]/default/user/profile
http://.../[app]/default/user/change_password
http://.../[app]/default/user/verify_email
http://.../[app]/default/user/retrieve_username
http://.../[app]/default/user/request_reset_password
http://.../[app]/default/user/reset_password
http://.../[app]/default/user/impersonate
http://.../[app]/default/user/groups
http://.../[app]/default/user/not_authorized
``:code
- **register** umožňuje uživatelům se registrovat. Integrovaná je CAPTCHA, ačkoli je defaultně zakázaná. Integrovaný je také client-side kalkulátor síly hesla, a to ve "web2py.js". Můžete použít validátor ``IS_STRONG`` a tak uživatelům zakázat používání slabých hesel.
- **login** slouží již registrovaným uživatelům k přihlašování (pokud registrace je ověřena a schválena nebo ověření resp. schválení nevyžaduje, a pokud uživatel není blokován).
- **logout** odhlásí uživatele, a navíc (podobně jako jiné metody) tuto událost loguje a může vyvolat nějakou odvozenou událost.
- **profile** umožňuje uživateli editovat jeho profil, čili obsah záznamu v tabulce ``auth_user``. Poznamenejme, že tato tabulka nemá pevnou strukturu a můžete ji rozšířit o další libovolná pole.
- **change_password** umožňuje bezpečným způsobem změnit heslo.
- **verify_email**. Jestliže je vyžadováno ověření registrace, uživatel dostane po dokončené registraci email s odkazem na tuto akci. Proklik odkazu a tím provedení této akce, ověří v registraci použitý email.
- **retrieve_username**. **Auth** defaultně k přihlášení používá email a heslo, ale alternativně může místo emailu používat uživatelské jméno (username). V takovém případě, zapomene-li uživatel své jméno, metoda ``retrieve_username`` umožní uživateli zadat emailovou adresu a získat zapomenuté jméno uživatele.
- **request_reset_password**. umožní uživateli, který zapomněl své heslo, si vyžádat nové. Tím dostane email s odkazem na stránku s možným resetem hesla.
- **impersonate** umožní uživateli simulovat běh jako jiný uživatel. To se hodí pro ladění a pro podporu (support) aplikace. ``request.args[1]`` je id uživatele, jehož přihlášení chceme simulovat. Je to dovoleno jen tehdy, když aktuálně přihlášený uživatel ``has_permission('impersonate', db.auth_user, user_id)``. Můžete použít funkci ``auth.is_impersonating()`` a tak zjistit, zda je právě simulováno přihlášení někoho jiného.
- **groups** vypíše skupiny, v nichž je aktuálně přihlášený uživatel členem.
- **not_authorized** zobrazí chybu v případě, že se uživatel pokusí o přístup k funkcionalitě, ke které není oprávněn.
- **navbar** je helper, který generuje menu s odkazy login/register/apod.

Logout, profile, change_password, impersonate a groups jsou přístupné jen přihlášenému uživateli.

Defaultně jsou všechny tyto akce zveřejněny, ale můžete přístup omezit jen na některé z těchto akcí.

Všechny tyto metody můžete rozšířit nebo nahradit, jestliže vydědíte vlastní třídu z **Auth**.

Všechny metody je také možné používat z indiviuálních akcí. Například:

``
def mujlogin(): return dict(form=auth.login())
def mojeregistrace(): return dict(form=auth.register())
def mujprofil(): return dict(form=auth.profile())
...
``

Chcete-li nějakou akci povolit jen přihlášeným uživatelům, dekorujte tuto akci pomocí auth.requires_login():
``
@auth.requires_login()
def hello():
    return dict(message='hello %(first_name)s' % auth.user)
``:code

Dekorovat lze kteroukoli funkci, ne jen zveřejněné akce (zveřejněné akce jsou funkce kontrolérů, které nemají žádný parametr a nezačínají dvěma podtržítky).

Samozřejmě takto máme zatím stále jen velmi jednoduché řízení přístupu. Složitější případy si ukážeme později.

``auth.user``:inxx ``auth.user_id``:inxx ``auth.user_groups``.

-----
``auth.user`` obsahuje kopii záznamu z ``db.auth_user`` pro právě přihlášeného uživatele a ``None``, není-li uživatel zatím přihlášen. Navíc je zde ``auth.user_id``, což je totéž jako ``auth.user.id`` (id aktuálního uživatele) nebo ``None``. ``auth.user_groups`` je slovník (dictionary), kde klíč je vždy id skupiny, jejímž je přihlášený uživatel členem, a hodnota je název skupiny (group role).
-----

``otherwise``:inxx

Dekorátor ``auth.requires_login()``, případně další podobné dekorátory ``auth.requires_*``, mají volitelný argument ``otherwise``. Lze pomocí něj zadat řetězec nebo akci, kam přesměrovat uživatele v případě, že jeho přihlášení selže.

#### Restrikce při registraci

Jestliže chcete návštěvníkům umožnit se registrovat, ale nechcete jim používání webu dovolit, dokud není registrace schválena administrátorem, nastavte:
``
auth.settings.registration_requires_approval = True
``:code

Registraci uživatele pak můžete schválit třeba z administračního appadmin rozhraní. Najděte tabulku ``auth_user``. Registrace, která čeká na schválení, má ``registration_key`` ve stavu "pending". Registrace je schválená, jestliže toto pole změníte na prázdné.

V appadmin rozhraní také můžete blokovat uživatele - zabránit mu se přihlašovat. Najděte v tabulce ``auth_user`` uživatele a nastavte mu ``registration_key`` na "blocked". Poznamenejme ale, že to sice zabrání přihlášení uživatele, ale nevynutí to jeho odhlášení, jestliže už přihlášen je. Jako synonymum pro "blocked" lze použít také slovo "disabled" - efekt bude přesně stejný.

Můžete také pro návštěvníky úplně znemožnit přístup k registraci takto:
``
auth.settings.actions_disabled.append('register')
``:code

Podobně lze blokovat další (pod)akce **Auth** objektu.

Zde je příklad, kdy uživatele po provedené registraci automaticky ponecháme jako přihlášeného, ale další přihlášení (po odhlášení) mu už nedovolíme, dokud nezareaguje potvrzením ověřovacího emailu:

``
auth.settings.registration_requires_verification = True
auth.settings.login_after_registration = True
``:code


#### Integrace s OpenID, Facebook, apod.
``Janrain``:inxx ``OpenID``:inxx ``Facebook``:inxx ``LinkedIn``:inxx ``Google``:inxx ``MySpace``:inxx ``Flickr``:inxx

Můžete použít Web2py řízení přístupu (RBAC, Role Base Access Control) a autentikovat uživatele pomocí jiných služeb jako je OpenID, Facebook, LinkedIn, Google, Dropbox, MySpace, Flickr, apod.
Nejjednodušší cestou je použít Janrain Engage (dříve RPX) (janrain.com), nově Social Login.

Dropbox diskutujeme jako zvláštní případ v kapitole 14, protože umožňuje více než jen přihlášení, a sice poskytuje přihlášenému uživateli úložný prostor (služby ukládání).

Janrain Engage (Social Login) je služba, která poskytuje middleware autentikaci. Zaregistrujete se na janrain.com, zaregistrujete doménu (jméno vaší aplikace) a nastavíte URL adresy, které budete používat, poté získáte API klíč.

Potom změňte model vaší Web2py aplikace a umístěte někam za definici ``auth`` objektu následující řádky:

``
from gluon.contrib.login_methods.rpx_account import RPXAccount
auth.settings.actions_disabled=['register', 'change_password', 'request_reset_password']
auth.settings.login_form = RPXAccount(request,
    api_key='...',
    domain='...',
    url = "http://vase-vnejsi-adresa/%s/default/user/login" % request.application)
``:code

První řádek importuje novou metodu přihlášení, druhý zakáže lokální registraci a třetí řekne Web2py, aby použilo RPX přihlašování. Musíte zadat ``api_key``, které jste na službě janrain.com získali, doménu, kterou jste v registraci zvolili a externí ``url`` vaší přihlašovací stránky. Na janrain.com najdete údaje tak, že jdete do [Deployment][Application Settings]. Vpravo najdete "Application Info", klíč api_key zde vidíte jako "API Key (Secret)".

Domain je údaj "Application Domain", poté co z něj vynecháte úvodní "https://" a koncové ".rpxnow.com/"
Například když zaregisttujete stránku "secure.mywebsite.org", Janrain vytvoří tuto Application Domain "https://secure-mywebsite.rpxnow.com" a "secure-mywebsite" je jméno, které nastavíte jako 'domain='.


[[image @///image/en6900.png center 300px]]

Když se nový uživatel přihlásí poprvé, Web2py pro něj založí nový záznam v ``db.auth_user``. Použije pole ``registration_id`` a v něm uchová unikátní id uživatele. Většina autentikačních metod poskytne username, email, first_name a last_name, ale není to garantováno a záleží to na uživatelem zvolené metodě přihlášení. Jestliže se tentýž uživatel opakovaně přihlásí pomocí různých mechanismů (třeba jednou s OpenID a jindy pomocí Facebooku), Janrain ho nemusí rozpoznat jako téhož uživatele a může mu vystavit odlišné ``registration_id``.

Můžete si upravit mapování mezi údaji, které poskytne Janrain a daty v záznamu v tabulce ``db.auth_user``. Příklad pro Facebook:
``
auth.settings.login_form.mappings.Facebook = lambda profile:\
            dict(registration_id = profile["identifier"],
                 username = profile["preferredUsername"],
                 email = profile["email"],
                 first_name = profile["name"]["givenName"],
                 last_name = profile["name"]["familyName"])
``:code

Klíče slovníku jsou pole v ``db.auth_user`` a hodnoty jsou datové položky v profile objektu, který poskytne Janrain. Více zjistíte z online dokumentace na službě Janrain.

Janrain také vede statistiky o přihlášení uživatele.

Přihlašovací formulář je s Web2py RBAC plně integrován, stále můžete vytvářet skupiny, zařazovat uživatele do skupin, přidělovat oprávnění, blokovat uživatele, apod.

-----
Základní služby Janrain jsou zdarma pro 2500 uživatelů aplikace (09.2015). Pro větší počet je potřeba objednat placený program.

Jestliže se rozhodnete Janrain nevyužít a použít jednotlivé přihlašovací metody (LDAP, PAM, Google, OpenID, OAuth/Facebook, LinkedIn, apod.), je to také možné. Příslušné API popíšeme dále v této kapitole.
-----

#### CAPTCHA a reCAPTCHA

``CAPTCHA``:inxx ``reCAPTCHA``:inxx ``PIL``:inxx
Abyste zabránili robotům v registraci na vašich stránkách, možná budete chtít využít kontrolní obrázek (CAPTCHA). Web2py obsahuje podporu reCAPTCHA``recaptcha``:cite. reCAPTCHA je dobře navržena, zdarma, podporuje přístupnost (může přečíst slovo návštěvníkovi), je snadno nastavitelná a nevyžaduje instalaci dalších knihoven třetích stran.

Pro používání reCAPTCHA budete potřebovat toto:
- Zaregistrujte se na reCAPTCHA (google.com/recaptcha)``recaptcha``:cite a získejte tak k vašemu účtu klíče (PUBLIC_KEY, PRIVATE_KEY). Jsou to vlastně 2 řetězce.
- Do kódu ve vašem modelu přidejte následující, a sice někam za vytvoření objektu ``auth``:
``
from gluon.tools import Recaptcha
auth.settings.captcha = Recaptcha(request,
    'PUBLIC_KEY', 'PRIVATE_KEY')
``:code

reCAPTCHA nemusí pracovat na adresách 'localhost' nebo '127.0.0.1', protože je určena pro veřejně dostupné stránky.

``Recaptcha`` konstruktor má některé volitelné parametry:
``
Recaptcha(..., use_ssl=False, error_message='invalid', label='Verify:', options='')
``:code

Dále je zde experimentální argument ``ajax=True``, který pro recaptcha využívá Ajaxové API. Lze jej použít pro kteroukoli reCaptcha, ale byl přidán kvůli umožnění použití reCaptcha v LOAD formulářích (více viz v kapitole 12, o LOAD, které ve Web2py umožňuje začleňovat do stránky komponenty pomocí Ajaxu). Jedná se o experimentální parametr, protože možná bude nahrazen automatickou detekcí, zda je Ajax v daném případě potřeba.

Nepřehlédněte defaultní použití ``use_ssl=False``.

Pomocí ``options`` lze zadat konfigurační řetězec, např. ``options="theme:'white', lang:'fr'"``

Více podrobností najdete zde: [[reCAPTCHA http://www.google.com/recaptcha]]``recaptchagoogle``:cite  a zde [[customizing http://code.google.com/apis/recaptcha/docs/customization.html]].

Pokud nechcete používat reCAPTCHA, ale jiný systém, podívejte se na definici třídy ``Recaptcha`` v "gluon/tools.py", jejíž úpravou můžete snadno jiný CAPTCHA systém implementovat.

``Recaptcha`` není nic víc než helper, který je odvozen z helperu ``DIV``. Generuje fiktivní pole, které validuje pomocí ``reCaptcha`` služby a může proto být použito v jakémkoli formuláři, včetně uživatelsky definovaných FORM:

``
form = FORM(INPUT(...), Recaptcha(...), INPUT(_type='submit'))
``:code

Můžete jej vložit do všech SQLFORM formulářů takto:

``
form = SQLFORM(...)   # nebo SQLFORM.factory(...)
form.element('table').insert(-1, TR('', Recaptcha(...), ''))
``:code

#### Přizpůsobení ``Auth``

Volání
``
auth.define_tables()
``:code

definuje všechny potřebné **Auth** tabulky, které nebyly definovány dříve. Znamená to, že když to budete chtí udělat, můžete i definovat vlastní ``auth_user`` tabulku.

Je řada možností, jak auth přizpůsobit. Nejjednodušší je přidat do registrace uživatelů extra pole navíc:

``
## po příkazu: auth = Auth(db)
auth.settings.extra_fields['auth_user']= [
  Field('ulice'),
  Field('misto'),
  Field('psc'),
  Field('telefon')]
## před příkazem: auth.define_tables(username=True)
``

Stejně jako pro "auth_user" tabulku můžete pole navíc definovat i v jiných "auth_" tabulkách.
Použití metody ``extra_fields`` je doporučený způsob, protože nenaruší interní machanismus auth.

Jiný způsob, i když nikoli doporučený, je definovat tabulky zcela po svém. Jestliže tabulku deklarujete před ``auth.define_tables()``, bude použita místo defaultní tabulky. Můžete to udělat třeba takto:

``
## po příkazu: auth = Auth(db)
db.define_table(
    auth.settings.table_user_name,
    Field('krestni', length=128, default=''),
    Field('prijmeni', length=128, default=''),
    Field('email', length=128, default='', unique=True), # vyžadováno
    Field('password', 'password', length=512,            # vyžadováno
          readable=False, label='Password'),
    Field('ulice'),
    Field('misto'),
    Field('psc'),
    Field('telefon'),
    Field('registration_key', length=512,                # vyžadováno
          writable=False, readable=False, default=''),
    Field('reset_password_key', length=512,              # vyžadováno
          writable=False, readable=False, default=''),
    Field('registration_id', length=512,                 # vyžadováno
          writable=False, readable=False, default=''))

## nezapomeňte na validátory
custom_auth_table = db[auth.settings.table_user_name]    # odkaz na uživatelsky definovanou tabulku do proměnné
custom_auth_table.krestni.requires = \
  IS_NOT_EMPTY(error_message=auth.messages.is_empty)
custom_auth_table.prijmeni.requires = \
  IS_NOT_EMPTY(error_message=auth.messages.is_empty)
custom_auth_table.password.requires = [IS_STRONG(), CRYPT()]
custom_auth_table.email.requires = [
  IS_EMAIL(error_message=auth.messages.invalid_email),
  IS_NOT_IN_DB(db, custom_auth_table.email)]

auth.settings.table_user = custom_auth_table             # informovat auth objekt, aby použil custom_auth_table

## před příkazem: auth.define_tables()
``:code

Můžete přidat jakákoli pole chcete a změnit validace, ale je potřeba zachovat pole, označená v příkladu komentářem "vyžadováno".

Je důležité pole "password", "registration_key", "reset_password_key" a "registration_id" doplnit nastavením ``readable=False`` a ``writable=False``, protože návštěvník je nesmí mít přístupná.

Jestliže použijete pole s názvem "username", bude se při přihlašování používat místo pole "email". V tom případě musíte zase přidat validátor:
``
auth_table.username.requires = IS_NOT_IN_DB(db, auth_table.username)
``:code

Auth kešuje (záznam) přihlášeného uživatele pomocí session a to jsou údaje, které dostanete v ``auth.user``. Takže jestliže po změně obsahu polí chcete mít i aktuální obsah ``auth.user``, musíte resetovat session.


#### Přejmenování ``Auth`` tabulek
[renaming_auth_tables]

Aktuální jména ``Auth`` tabulek jsou uložena v:
``
auth.settings.table_user_name = 'auth_user'
auth.settings.table_group_name = 'auth_group'
auth.settings.table_membership_name = 'auth_membership'
auth.settings.table_permission_name = 'auth_permission'
auth.settings.table_event_name = 'auth_event'
``:code

Jména tabulek můžete změnit přiřazením do uvedených proměnných, a sice poté, kdy je vytvořen objekt ``auth`` a dříve než je voláno auth.define_tables(). Například:
``
auth = Auth(db)
auth.settings.table_user_name = 'uzivatele'
#...
auth.define_tables()
``:code

Na tabulky se kromě jejich aktuálního jména můžete odkazovat i takto (nezávisle na konkrétním jménu):
``
auth.settings.table_user
auth.settings.table_group
auth.settings.table_membership
auth.settings.table_permission
auth.settings.table_event
``:code

Poznámka: auth.signature se normálně definuje už při vytvoření auth objektu, tedy dříve, než změníte jména tabulek. Je potřeba tomu zabránit, a sice takto:

``
auth = Auth(db, signature=False)
``

Tím se auth.signature definuje až při volání auth.define_tables(), jak v tomto případě potřebujeme.


#### Další přihlašovací (login) metody a formuláře

``LDAP``:inxx ``PAM``:inxx

Auth nabízí mnoho přihlašovacích metod a další možnosti (hooks), jak umožnit nové přihlašovací metody. Každé podporované přihlašovací metodě odpovídá jeden soubor v adresáři
``
gluon/contrib/login_methods/
``:code

Dokumentaci pro odpovídající metodu najdete přímo v samotných souborech, nicméně zde si ukážeme nějaké příklady.

Především potřebujeme rozlišovat mezi dvěma typy alternativních přihlašovacích metod:
- metody, které využívají přihlašovací formulář Web2py (ačkoli údaje jsou verifikovány mimo Web2py). Příkladem je LDAP.
- metody, které vyžadují externí přihlašovací formulář (příkladem je Google nebo Facebook).

Ve druhém případě Web2py nikdy nezíská přihlašovací údaje, jen přihlašovací token (řetězec), vystavený provozovatelem služby. Token je uložen do ``db.auth_user.registration_id``.

Ukažme si příklady první varianty:

##### Basic

Dejme tomu, že máte autentikační službu, např. na adrese

``
https://basic.example.com
``:code

která akceptuje základní autentikaci (basic access authentication). To znamená, že server akceptuje HTTP požadavek s tímto formátem hlavičky:

``
GET /index.html HTTP/1.0
Host: basic.example.com
Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
``:code

kde poslední řetězec je base64 zakódovaný řetězec username:password. Služba odpoví 200 OK v případě úspěšného ověření, jinak 400, 401, 402, 403 nebo 404.

Chcete zadat uživatelské jméno a heslo do standardního ``Auth`` přihlašovacího formuloře a ověřit je pomocí uvedené služby. Všechno, co k tomu potřebujete, je přidat do vaší aplikace tento kód:
``
from gluon.contrib.login_methods.basic_auth import basic_auth
auth.settings.login_methods.append(
    basic_auth('https://basic.example.com'))
``:code

``auth.settings.login_methods`` je seznam autentikačních metod, které se provedou postupně.
Defaultní nastavení je takovéto:
``
auth.settings.login_methods = [auth]
``:code

Když rozšíříte seznam o alternativní metodu, například ``basic_auth``, **Auth** se nejprve pokusí přihlásit návštěvníka pomocí tabulky ``auth_user`` a když se to nepovede, zkusí následující metodu v seznamu. Jestiže ta uspěje a ověří uživatele a jestliže ``auth.settings.login_methods[0]==auth``, ``Auth`` podnikne následující:
- jestliže uživatel zatím neexistuje v ``auth_user``, vytvoří v této tabulce záznam pro nového uživatele a uloží jméno a heslo.
- jestliže uživatel v ``auth_user`` existuje, ale heslo v tabulce neodpovídá novému heslu (akceptovanému basic službou), nahradí staré heslo novým (hesla jsou ovšem vždy hashována, pokud není explicitně požadováno něco jiného).

Jestliže nechcete změněné heslo ukládat do ``auth_user``, stačí změnit pořadí přihlašovacích metod nebo lze metodu ``auth`` ze seznamu zcela vypustit. Například:
``
from gluon.contrib.login_methods.basic_auth import basic_auth
auth.settings.login_methods = \
    [basic_auth('https://basic.example.com')]
``:code

Totéž chování dostanete i pro ostatní metody, které zde popisujeme.

##### SMTP a Gmail
``SMTP``:inxx ``Gmail``:inxx

Můžete ověřit přihlašovací údaje pomocí některého SMTP serveru, např. pomocí Gmailu. Jinak řečeno, uživatele přihlásíte, pokud zadá svoji platnou e-mailovou adresu Gmailu a heslo, neboli pokud se bude jednat o platné přihlašovací údaje ke Gmail SMTP serveru (``smtp.gmail.com:587``). K tomu je potřeba následující kód:
``
from gluon.contrib.login_methods.email_auth import email_auth
auth.settings.login_methods.append(
    email_auth("smtp.gmail.com:587", "@gmail.com"))
``:code

První argument pro ``email_auth`` je adresa:port SMTP serveru. Druhý argument je doména emailu.

Lze to použít pro kterýkoli SMTP server s TLS autentikací.``TLS``:inxx

##### PAM
``PAM``:inxx

Jedná se o standardně implementovanou autentikaci v systémech typu UNIX/Linux. Autentikace pomocí Pluggable Authentication Modules (PAM) pracuje stejně jako v předchozích případech a umožňuje Web2py autentikovat uživatele pomocí jejich účtu v operačním systému:
``
from gluon.contrib.login_methods.pam_auth import pam_auth
auth.settings.login_methods.append(pam_auth())
``:code

##### LDAP
``LDAP``:inxx

Autentikace pomocí LDAP pracuje velice podobně předchozím případům.

Pro použití LDAP přihlášení s MS Active Directory:``Active Directory``:inxx
``
from gluon.contrib.login_methods.ldap_auth import ldap_auth
auth.settings.login_methods.append(ldap_auth(mode='ad',
   server='my.domain.controller',
   base_dn='ou=Users,dc=domain,dc=com'))
``:code

Pro LDAP přihlášení s Lotus Notes a Domino:``Lotus Notes``:inxx ``Domino``:inxx
``
auth.settings.login_methods.append(ldap_auth(mode='domino',
   server='my.domino.server'))
``:code

Pro LDAP přihlášení s OpenLDAP (s UID):``OpenLDAP``:inxx
``
auth.settings.login_methods.append(ldap_auth(server='my.ldap.server',
   base_dn='ou=Users,dc=domain,dc=com'))
``:code

Pro LDAP přihlášení s OpenLDAP (s CN):
``
auth.settings.login_methods.append(ldap_auth(mode='cn',
   server='my.ldap.server', base_dn='ou=Users,dc=domain,dc=com'))
``:code

##### Google App Engine
``GAE login``:inxx

Autentikace pomocí Google účtu, když provozujete aplikaci na Google App Engine, vyžaduje vynechat Web2py přihlašovací formulář a místo něj být přesměrován na přihlašovací stránku Googlu a po úspěšném přihlášení zpět. Protože je chování oproti předchozím případům odlišné, liší se i API.

``
from gluon.contrib.login_methods.gae_google_login import GaeGoogleAccount
auth.settings.login_form = GaeGoogleAccount()
``:code

##### OpenID
``OpenID``:inxx

Dříve jsme probrali integraci se službou Janrain (která má podporu OpenID) a to je nejsnazší způsob, jak OpenID použít. Ale někdy nechcete být závislí na službě třetí strany a chcete použít poskytovatele OpenID (OpenID provider) přímo z klienta (vaší aplikace).

Tady je příklad:

``
from gluon.contrib.login_methods.openid_auth import OpenIDAuth
auth.settings.login_form = OpenIDAuth(auth)
``:code

``OpenIDAuth`` vyžaduje, aby byl instalován modul ''python-openid''. Tato přihlašovací metoda si nadefinuje následující tabulku:

``
db.define_table('alt_logins',
    Field('username', length=512, default=''),
    Field('type', length =128, default='openid', readable=False),
    Field('user', self.table_user, readable=False))
``:code

do ní se uloží openid jména uživatelů pro jednotlivé uživatele. Jestliže chcete zobrazit openid jména aktuálně přihlášeného uživatele, použijte (v tomto příkladu v šabloně):

``
{{=auth.settings.login_form.list_user_openids()}}
``:code

##### OAuth2.0
``OAuth``:inxx ``Facebook``:inxx ``Google``:inxx ``Twitter``:inxx

Opět je integrace možná pomocí služby Janrain, ale pro případ, že nechcete záviset na cizí službě a chcete použít OAuth2.0 providera přímo.
Například Facebook, Linkedin, Twitter, Google vesměs poskytují OAuth2.0 autentikační službu.
Web2py transparentně ošetří komunikaci s OAuth2.0, takže uživatel může býtověřen proti kterémukoli OAuth2.0 poskytovateli, kterého konfigurujete.
Kromě autentikace může OAuth2.0 provider poskytovat Web2py aplikaci omezený přístup k datům uživatele pomocí proprietárního rozhraní (API). Google, Twitter, Facebook, apod. vesměs mají vlastní API rozhraní, které můžete snadno použít z Web2py aplikace.

Je potřeba říci, že OAuth2.0 je omezena jen na autentikaci a autorizaci
(kdežto např. CAS (Centrální autentizace stránek) poskytuje větší funkčnost), a to znamená, že každý OAuth2.0 poskytovatel
má odlišný způsob (rozhraní), jak získat unikátní id a informace o něm z databáze uživatelů tohoto poskytovatele.
Konkrétní metody bývají dobře popsány v dokumentaci příslušného poskytovatele a jedná se obvykle o jednoduchá REST volání. Z tohoto důvodu je tedy potřeba pro každého konkrétního poskytovatele dopsat nějaký kód.

Než kód dopíšeme, první krok je společný pro všechny poskytovatele: zaregistrovat novou aplikaci. Dělá se to nejčastěji na stránkách poskytovatele a popisuje to jeho dokumentace.

Při přidání nového OAuth2.0 poskytovatele do vaší aplikace je pak potřeba znát několik údajů:
application:
 1. adresu pro autorizaci (Authorization URI),
 2. adresu pro Token request (Token request URI),
 3. aplikační identifikační token a heslo (secret), které jste získali registrací aplikace u poskytovatele,
 4. oprávnění, která poskytovatel dává Web2py aplikaci ("scope", viz dokumentace poskytovatele),
 5. API volání pro získání UID autentizovaného uživatele, rovněž z dokumentace.
 
Body 1 až 4 nám poslouží ke konfiguraci autorizačního přípojného bodu, který Web2py použije ke komunikaci s OAuth2.0 poskytovatelem.
Unikátní id potřebuje Web2py získávat voláním metody get_user(), když je to během procesu přihlášení potřeba. A právě k tomu potřebujeme znát API volání podle bodu 5.

Toto jsou podstatné změny, které je potřeba někde ve vašem modelu provést:
 a. importovat třídu OAuthAccount;
 b. definovat odvozenou OAuthClass implementaci (zdědit uvedenou třídu);
 c. přepsat metodu __init__() zděděné třídy;
 d. přepsat metodu get_user() zděděné třídy;
 e. instanciovat výslednou třídu s předáním údajů podle výše uvedených bodů 1-4;

Jakmile provedeme instanciování třídy a jakmile je uživatel autentikován, může Web2py aplikace kdykoli přistupovat k API rozhraní poskytovatele tím, že použije přístupový token pro OAuth2.0, a to voláním metody accessToken() naší třídy.

Dále uvádíme příklad, jak to může pracovat v případě Facebooku. Je to jen základní příklad použití Graph API Facebooku,
takže mějte na paměti, že vhodným návrhem metody get_user() můžete dělat mnohem více. Příklad ukazuje, jak může být použit přístupový token pro OAuth2.0 k volání vzdáleného API rozhraní poskytovatele.

Nejprve musíme instalovat [[Facebook Python SDK https://github.com/pythonforfacebook/facebook-sdk/]].

Dále budete potřebovat tento kód ve vašem modelu:

``
## Definujeme oauth aplikační id a heslo (secret).
FB_CLIENT_ID='xxx'
FB_CLIENT_SECRET="yyyy"

## importujeme potřebné moduly
try:
    import json
except ImportError:
    from gluon.contrib import simplejson as json
from facebook import GraphAPI, GraphAPIError
from gluon.contrib.login_methods.oauth20_account import OAuthAccount

## zdědíme a rozšíříme OAUthAccount třídu
class FaceBookAccount(OAuthAccount):
    """OAuth implementace pro FaceBook"""
    AUTH_URL="https://graph.facebook.com/oauth/authorize"
    TOKEN_URL="https://graph.facebook.com/oauth/access_token"

    def __init__(self):
        OAuthAccount.__init__(self, None, FB_CLIENT_ID, FB_CLIENT_SECRET,
                              self.AUTH_URL, self.TOKEN_URL,
                              scope='email, user_about_me, user_activities, user_birthday, user_education_history, user_groups, user_hometown, user_interests, user_likes, user_location, user_relationships, user_relationship_details, user_religion_politics, user_subscriptions, user_work_history, user_photos, user_status, user_videos, publish_actions, friends_hometown, friends_location, friends_photos',
                              state="auth_provider=facebook",
                              display='popup')
        self.graph = None

    def get_user(self):
        '''Vrátí údaje uživatele za pomoci Graph API."""
        if not self.accessToken():
            return None

        if not self.graph:
            self.graph = GraphAPI((self.accessToken()))

        user = None
        try:
            user = self.graph.get_object("me")
        except GraphAPIError, e:
            session.token = None
            self.graph = None

        if user:
            if not user.has_key('username'):
                username = user['id']
            else:
                username = user['username']
                
            if not user.has_key('email'):
                email = '%s.fakemail' %(user['id'])
            else:
                email = user['email']    

            return dict(first_name = user['first_name'],
                        last_name = user['last_name'],
                        username = username,
                        email = '%s' %(email) )

## použijeme předchozí třídu pro vytvoření přihlašovacího formuláře
auth.settings.login_form = FaceBookAccount()
``:code

##### LinkedIn
``LinkedIn``:inxx

Takto můžeme pracovat s LinkedIn přímo (bez služby Janrain) a mít tím přístup k více informacím, než kolik umožňuje přístup prostřednictvím Janrain.

Tady je příklad:

``
from gluon.contrib.login_methods.linkedin_account import LinkedInAccount
auth.settings.login_form = LinkedInAccount(request, KEY, SECRET, RETURN_URL)
``:code

``LinkedInAccount`` vyžaduje mít instalovaný modul "python-linkedin".

##### X509

Je také možné přihlašovat se pomocí předání x509 certifikátu stránce, kdy vaše údaje (credential) budou extrahovány z certifikátu. K tomu je potřeba mít instalováno ``M2Crypto`` z některého z odkazů

``
http://chandlerproject.org/bin/view/Projects/MeTooCrypto
https://pypi.python.org/pypi/M2Crypto
``
Je-li M2Crypto nainstalováno, pak můžete provést toto:

``
from gluon.contrib.login_methods.x509_auth import X509Account
auth.settings.actions_disabled = ['register', 'change_password', 'request_reset_password']
auth.settings.login_form = X509Account()
``:code

Nyní se lze do Web2py aplikace přihlašovat předáním vašeho x509 certifikátu. Jak to dělat, závisí na prohlížeči, ale pravděpodobně spíše požijete certifikáty pro přístup k web services. V takovém případě můžete odzkoušet autentikaci např. pomocí ``cURL``:

``
curl -d "firstName=John&lastName=Smith" -G -v --key private.key \
     --cert  server.crt https://example/app/default/user/profile
``

Takto to pracuje bez dalších úprav s Rocket serverem (vestavěný webový server ve Web2py), ale jestliže používáte jiný webový server, je možné, že budete muset provést další konfiguraci navíc. Konkrétně je potřeba webovému serveru zadat, kde jsou umístěny lokální certifikáty a že má ověřovat certifikáty z klientů. Tato nastavení závisí na konkrétním serveru, takže je neuvádíme zde.

##### Více přihlašovacích formulářů

Některé přihlašovací metody modifikují přihlašovací formulář, kdežto jiné ne. Pokud přihlašovací formulář mění, vzniká problém s jejich společnou existencí v rámci jedné stránky. Web2py nabízí možnost, jak to zařídit. Tady je příklad, který nabízí současně normální login (auth) a RPX login (janrain.com):

``
from gluon.contrib.login_methods.extended_login_form import ExtendedLoginForm
other_form = RPXAccount(request, api_key='...', domain='...', url='...')
auth.settings.login_form = ExtendedLoginForm(auth, other_form, signals=['token'])
``:code

Jestliže jsou nastaveny signals a parametry v požadavku (requestu) odpovídají všem signals,
bude vráceno volání ``other_form.login_form``.
``other_form`` může řešit nějaké specifické situace, například v několika krocích přihlášení OpenID, pomocí ``other_form.login_form``.

V opačném případě je renderován standardní přihlašovací formulář spolu s ``other_form``.

#### Verzování záznamů

Auth můžete využít k udržování úplné historie záznamů:

``
auth.enable_record_versioning(db,
    archive_db=None,
    archive_names='%(tablename)s_archive',
    current_record='current_record'):
``:code

Tím Web2py řeknete, aby vytvořilo ke každé tabulce ``db`` další archivní tabulku a ukládalo do ní kopii záznamu (starý stav) před každou modifikací.

Poslední tři parametery jsou volitelné:

- ``archive_db`` umožní přesměrovat archivní tabulky do jiné databáze. Nastavení ``None`` je identické s nastavením ``db`` - archivní tabulky se vytvoří tamtéž, jako "živé" tabulky.
- ``archive_names`` je předloha pro vytváření jmen archivních tabulek.
- ``current_record`` je jméno pole, které v archivní tabulce obsahuje odkaz na původní záznam. Poznamenejme, že pro případ jiného umístění archivních tabulek ``archive_db!=db`` se místo pole typu odkaz (reference) vytvoří obyčejný integer - protože (automatické) odkazy (reference) mezi databázemi nejsou možné.


Archivují se jen tabulky s poli ``modified_by`` a ``modified_on`` (jak je např. vytvoří auth.signature).

Jestliže povolíte verzování (uchovávání historie záznamů) a když záznamy mají i pole ``is_active`` (také jej lze vytvořit pomocí auth.signature),
záznamy nebudou fyzicky rušeny, ale místo toho budou označeny nastavením ``is_active=False``.
``enable_record_versioning`` přidá ``common_filter`` ke každé verzované tabulce tak, aby záznamy s nastavením ``is_active=False`` nebyly vidět (tj. aby se práce s tabulkou jevila tak, jako by záznamy byly zrušeny fyzicky).

Jestliže povolíte verzování (``enable_record_versioning``), nepoužívejte ``auth.archive``, ani ``crud.archive``, v opačném případě se vám budou vytvářet duplikátní záznamy.
Tyto funkce dělají právě to, co dělá ``enable_record_versioning`` automaticky - proto je považujme za zastaralé (deprecated).


[[mail_and_auth]]
#### ``Mail`` a ``Auth``

O Web2py rozhraní (API) pro emaily a o konfiguraci emailů se dočtete více v kapitole 8. Zde pouze vysvětlíme vztahy mezi ``Mail`` a ``Auth``.

Můžete definovat vlastní odesílání mailů

``
from gluon.tools import Mail
mail = Mail()
mail.settings.server = 'smtp.example.com:25'
mail.settings.sender = 'you@example.com'
mail.settings.login = 'username:password'

``

a nebo jednoduše převzít existující objekt odesílání mailů z objektu ``auth``:

``
mail = auth.settings.mailer
mail.settings.server = 'smtp.example.com:25'
mail.settings.sender = 'you@example.com'
mail.settings.login = 'username:password'
``

Musíte samozřejmě uvést správná nastavení vašeho SMTP serveru. Nastavení ``mail.settings.login = None`` použijte, pokud SMTP server nevyžaduje autentikaci. Nechcete-li použít TLS, nastavte navíc ``mail.settings.tls = False``.


V ``Auth`` je defaultně vypnuta verifikace pomocí emailů.
Povolit ji můžete tak, že do modelu, který zakládá objekt ``auth``, doplníte:

``
auth.settings.registration_requires_verification = True
auth.settings.registration_requires_approval = False
auth.settings.reset_password_requires_verification = True
auth.messages.verify_email = 'Klikněte na odkaz %(link)s pro ověření vašeho mailu'
auth.messages.reset_password = 'Klikněte na odkaz %(link)s pro reset vašeho hesla'
``:code

Je možné, že v obou ``auth.messages`` budete ještě muset provést náhradu vloženého URL na správné znění URL. To je potřeba v případě, že je Web2py instalováno za proxy a nedokáže zcela jistě určit vlastní veřejnou adresu. Nicméně jednoduchá verze v právě uvedených příkladech (které jsou v anglickém znění defaultním nastavením) by měla téměř vždy fungovat.

[[two_step_verification]]
#### Dvoukrokové ověření

Dvoukrokové ověření (two-step nebo two-factor autentikace) je způsob zvýšení bezpečnosti autentikace. Takové nastavení přidá další krok navíc do procesu přihlášení.
V prvním kroku je uživateli nabídnut standardní formulář se jménem a heslem. Jestliže uživatel zadá údaje správně (a je vyžadováno dvoukrokové ověření), je před přihlášením promítnut další formulář,
který se ptá na 6 číslic, odeslaných v emailu na emailovou adresu uživatele (server odešle email na základě toho, že jméno a heslo byly zadány správně). Uživatel má 4 pokusy na zadání kódu, pokud se mu to nepovede, musí opakovat celý postup.

Popsaná funkcionalita může také být nastavena jen pro některé uživatele:

- Vytvořte skupinu (group) pro dvoukrokové ověření, pojmenovanou např. ``auth2step`` a s popisem třeba ``Dvoukrokove overeni``.
- Zařaďte uživatele do této skupiny.
- Přidejte následující nastavení v modelu, který vytváří objekt auth (typicky v db.py):
``
auth.settings.two_factor_authentication_group = "auth2step"
``:code
- Nezapomeňte konfigurovat nastavení emailového serveru v db.py.

### Autorizace

Při registraci nového uživatele se vytvoří skupina (group) s tímto uživatelem. Její jméno je "user_[id]", přičemž [id] je id nového uživatele. Vytváření těchto skupin můžete zabránit nastavením
``
auth.settings.create_user_groups = None
``:code

i když to nedoporučujeme. Poznamenejme, že ``create_user_groups`` není boolean (ačkoli může být nastaveno na ``False``), ale jeho default je:

``
auth.settings.create_user_groups="user_%(id)s"
``:code

Obsahuje tedy předlohu pro vytvoření jména skupiny na základě ``id`` uživatele.

Uživatelé jsou zařazeni (have membership) do skupin (groups). Každá skupina je identifikována pomocí údaje ``role`` (jména skupiny). Skupinám jsou přiřazena oprávnění (permissions). Uživatelé nabývají oprávnění tím, že jsou členové některé skupiny nebo některých skupin. Pokud nepotlačíte defaultní chování (jak jsme jej právě pospali), je každý uživatel zařazen alespoň do pro něj vytvořené skupiny.

Můžete také provést nastavení např.
``
auth.settings.everybody_group_id = 5
``:code

a tím je každý nový uživatel také automaticky zařazen do skupiny s id 5. Předpokládá se, že skupina je už vytvořena. 5 je samozřejmě jen příklad, id skupiny zjistíte takto:
``
auth.id_group('role(jmeno)')
``:code

Skupiny můžete vytvářet pomocí **appadmin** rozhraní nebo programově těmito metodami:
``
auth.add_group('role(jmeno)', 'popis')
``:code

Metoda vrátí id právě vytvořené skupiny.
Pozn. překladatele: pro pojmenování (role) nepoužívejte raději diakritiku.

``
auth.del_group(group_id)
``:code

zruší skupinu s id ``group_id``.

``
auth.del_group(auth.id_group('user_7'))
``:code

zruší skupinu, pojmenovanou "user_7", čili skupinu unikátně vytvořenou pro uživatele id 7.

``
auth.user_group(user_id)
``:code

vrátí id skupiny unikátně vytvořené pro uživatele (se jménem ``user_id``) nebo None, pokud skupina neexistuje.

``
auth.add_membership(group_id, user_id)
``:code

zařadí uživatele ``user_id`` do skupiny ``group_id``.
Pokud není zadáno ``user_id``, Web2py předpokládá právě přihlášeného uživatele.

``
auth.del_membership(group_id, user_id)
``:code

zruší členstí uživatele ``user_id`` ve skupině ``group_id``.
Opět, pokud není zadáno ``user_id``, Web2py předpokládá právě přihlášeného uživatele.

``
auth.has_membership(group_id | role, user_id)
``:code

zjistí, zda uživatel ``user_id`` je členem skupiny, skupinu zadáme prvním parametrem buď pomocí jejího ``group_id`` nebo jménem (role).
Pokud není zadáno ``user_id``, Web2py předpokládá právě přihlášeného uživatele.

``
auth.add_permission(group_id, 'name', 'object', record_id)
``:code

dá skupině s id ``group_id`` (tedy jejím členům) oprávnění pojmenované "name" (libovolně volitelné) pro objekt "object" (také libovolně volitelné jméno). Jestliže "object" je jméno tabulky, oprávnění se bude vztahovat k celé tabulce, když uvedete jako ``record_id`` nulu, a nebo se oprávnění může vztahovat jen k jedinému záznamu (record), když zadáte odpovídající ``record_id`` (hodnotu větší než nula). Když dáváte oprávnění k tabulkám, je praktické používat jména oprávnění ("name") z množiny ('create', 'read', 'update', 'delete', 'select'), protože tato jména jsou známá pro CRUD rozhraní, které je může automaticky uplatňovat.

Jestliže ``group_id`` je nula, Web2py použije skupinu, vytvořenou unikátně pro právě přihlášeného uživatele.

You can also use ``auth.id_group(role="...")`` to get the id of a group given its name. ``id_group``:inxx

``
auth.del_permission(group_id, 'name', 'object', record_id)
``:code

revokes the permission.

``
auth.has_permission('name', 'object', record_id, user_id)
``:code

checks whether the user identified by ``user_id`` has membership in a group with the requested permission.

``
rows = db(auth.accessible_query('read', db.mytable, user_id))\
    .select(db.mytable.ALL)
``:code

returns all rows of table "mytable" that user ``user_id`` has "read" permission on.
If the ``user_id`` is not specified, then web2py assumes the current logged-in user.
The ``accessible_query(...)`` can be combined with other queries to make more complex ones.
``accessible_query(...)`` is the only **Auth** method to require a JOIN, so it does not work on the Google App Engine.

Assuming the following definitions:
``
>>> from gluon.tools import Auth
>>> auth = Auth(db)
>>> auth.define_tables()
>>> secrets = db.define_table('document', Field('body'))
>>> james_bond = db.auth_user.insert(first_name='James',
                                     last_name='Bond')
``:code

Here is an example:
``
>>> doc_id = db.document.insert(body = 'top secret')
>>> agents = auth.add_group(role = 'Secret Agent')
>>> auth.add_membership(agents, james_bond)
>>> auth.add_permission(agents, 'read', secrets)
>>> print auth.has_permission('read', secrets, doc_id, james_bond)
True
>>> print auth.has_permission('update', secrets, doc_id, james_bond)
False
``:code

#### Decorators

The most common way to check permission is not by explicit calls to the above methods, but by decorating functions so that permissions are checked relative to the logged-in visitor. Here are some examples:
``
def function_one():
    return 'this is a public function'

@auth.requires_login()
def function_two():
    return 'this requires login'

@auth.requires_membership('agents')
def function_three():
    return 'you are a secret agent'

@auth.requires_permission('read', secrets)
def function_four():
    return 'you can read secret documents'

@auth.requires_permission('delete', 'any file')
def function_five():
    import os
    for file in os.listdir('./'):
        os.unlink(file)
    return 'all files deleted'

@auth.requires(auth.user_id==1 or request.client=='127.0.0.1', requires_login=True)
def function_six():
    return 'you can read secret documents'

@auth.requires_permission('add', 'number')
def add(a, b):
    return a + b

def function_seven():
    return add(3, 4)
``:code

The condition argument of ``@auth.requires(condition)`` can be a callable and unless the condition is simple, it better to pass a callable than a condition since this will be faster, as the condition will only be evaluated if needed. For example

``
@auth.requires(lambda: check_condition())
def action():
    ....
``:code

``@auth.requires`` also takes an optional argument ``requires_login`` which defaults to ``True``. If set to False, it does not require login before evaluating the condition as true/false. The condition can be a boolean value or a function evaluating to boolean.

Note that access to all functions apart from the first one is restricted based on permissions that the visitor may or may not have.

If the visitor is not logged in, then the permission cannot be checked; the visitor is redirected to the login page and then back to the page that requires permissions.

#### Combining requirements

Occasionally, it is necessary to combine requirements. This can be done via a generic ``requires`` decorator which takes a single argument, a true or false condition. For example, to give access to agents, but only on Tuesday:
``
@auth.requires(auth.has_membership(group_id='agents' \
               and request.now.weekday()==1)
def function_seven():
    return 'Hello agent, it must be Tuesday!'
``:code

or equivalently:
``
@auth.requires(auth.has_membership(role='Secret Agent') \
               and request.now.weekday()==1)
def function_seven():
    return 'Hello agent, it must be Tuesday!'
``:code

#### Authorization and CRUD

Using decorators and/or explicit checks provides one way to implement access control.

Another way to implement access control is to always use CRUD (as opposed to ``SQLFORM``) to access the database and to ask CRUD to enforce access control on database tables and records. This is done by linking ``Auth`` and CRUD with the following statement:
``
crud.settings.auth = auth
``:code

This will prevent the visitor from accessing any of the CRUD functions unless the visitor is logged in and has explicit access. For example, to allow a visitor to post comments, but only update their own comments (assuming crud, auth and db.comment are defined):
``
def give_create_permission(form):
    group_id = auth.id_group('user_%s' % auth.user.id)
    auth.add_permission(group_id, 'read', db.comment)
    auth.add_permission(group_id, 'create', db.comment)
    auth.add_permission(group_id, 'select', db.comment)

def give_update_permission(form):
    comment_id = form.vars.id
    group_id = auth.id_group('user_%s' % auth.user.id)
    auth.add_permission(group_id, 'update', db.comment, comment_id)
    auth.add_permission(group_id, 'delete', db.comment, comment_id)

auth.settings.register_onaccept = give_create_permission
crud.settings.auth = auth

def post_comment():
   form = crud.create(db.comment, onaccept=give_update_permission)
   comments = db(db.comment).select()
   return dict(form=form, comments=comments)

def update_comment():
   form = crud.update(db.comment, request.args(0))
   return dict(form=form)
``:code

You can also select specific records (those you have 'read' access to):
``
def post_comment():
   form = crud.create(db.comment, onaccept=give_update_permission)
   query = auth.accessible_query('read', db.comment, auth.user.id)
   comments = db(query).select(db.comment.ALL)
   return dict(form=form, comments=comments)
``:code

The permissions names enforced by :

``
crud.settings.auth = auth
``:code

are "read", "create", "update", "delete", "select", "impersonate".

#### Authorization and downloads

The use of decorators and the use of ``crud.settings.auth`` do not enforce authorization on files downloaded by the usual download function
``
def download(): return response.download(request, db)
``:code

If one wishes to do so, one must declare explicitly which "upload" fields contain files that need access control upon download.
For example:
``
db.define_table('dog',
   Field('small_image', 'upload'),
   Field('large_image', 'upload'))

db.dog.large_image.authorize = lambda record: \
   auth.is_logged_in() and \
   auth.has_permission('read', db.dog, record.id, auth.user.id)
``:code

The attribute ``authorize`` of upload field can be None (the default) or a function that decides whether the user is logged in and has permission to 'read' the current record. In this example, there is no restriction on downloading images linked by the "small_image" field, but we require access control on images linked by the "large_image" field.


[[basic_authentication]]
#### Access Control and Basic Authentication

Occasionally, it may be necessary to expose actions that have decorators that require access control as services; i.e., to call them from a program or script and still be able to use authentication to check for authorization.

**Auth** enables login via basic authentication:
``
auth.settings.allow_basic_login = True
``:code

With this set, an action like
``
@auth.requires_login()
def give_me_time():
    import time
    return time.ctime()
``:code

can be called, for example, from a shell command:
``
wget --user=[username] --password=[password]
    http://.../[app]/[controller]/give_me_time
``:code

It is also possible to log in by calling ``auth.basic()`` rather than using an ``@auth`` decorator:
``
def give_me_time():
    import time
    auth.basic()
    if auth.user:
        return time.ctime()
    else:
        return 'Not authorized'
``:code

Basic login is often the only option for services (described in the next chapter), but it is disabled by default.

#### Application Management via privileged users (Experimental)
Normally administrator functions such as defining users and groups are managed by the server administrator. However, you may want a group of privileged users to have administrator rights for a specific application. 
This is possible with versions after web2py v2.5.1 
(Upgrading an existing application requires the new appadmin controller and the new appadmin.html view, copied from the welcome app. Also, apps created prior to web2py v2.6 need the new javascript file in welcome/static/js/web2py.js)

The concept allows different management settings, each of which allows a user group to edit a certain set of tables in this application.

Example:
First, create a group (also known as a role) for your privileged users. In this example, it will be called admin.
Give a user membership of this role.
Second, think of a name to describe this management setting, such as db_admin.

Add the following setting in the model where you created and configured your auth object (probably in the model db):
``
auth.settings.manager_actions = dict(db_admin=dict(role='admin',heading='Manage Database',tables = db.tables))

``:code


A menu item has the URL like below, passing the management setting name as an arg:
``
URL('appadmin','manage',args=['db_admin'])
``:code
This URL appears as /appadmin/manage/auth.

##### Advanced use
This mechanism allows multiple management settings; each additional management setting is just another key defined in auth.settings.manager_actions.

For example, you may want a group of users (such as 'Super') to have access to every table in a management setting called "db_admin", and another group (such as 'Content Manager') to have admin access to tables relating to content in a management setting called "content_admin". 

This can be set up like this:
``
auth.settings.manager_actions = dict(
    db_admin=dict(role='Super', heading='Manage Database', tables=db.tables),
    content_admin=dict(role='Content Manager', tables=[content_db.articles, content_db.recipes, content_db.comments])
    content_mgr_group_v2 = dict(role='Content Manager v2', db=content_db,
        tables=['articles','recipes','comments'],
        smartgrid_args=dict(
           DEFAULT=dict(maxtextlength=50,paginate=30), 
           comments=dict(maxtextlength=100,editable=False)
        )
     )
``:code

(The heading key is optional. If missing, a smart default will be used)

You could then make two new menu items with these URLs:
``
URL('appadmin','manage',args=['db_admin'])
URL('appadmin','manage',args=['content_admin'])
``:code

The management setting called "content_mgr_group_v2" shows some more advanced possibilities. The key smartgrid_args is passed to the smartgrid used to edit or view the tables. Apart from the special key DEFAULT, table names are passed as keys (such as the table called "comments"). The syntax in this example names the tables as a list of strings, using the key db=content_db to specify the database.

#### Manual Authentication

Some times you want to implement your own logic and do "manual" user login.
This can also be done by calling the function:

``
user = auth.login_bare(username,password)
``:code

``login_bare`` returns user if the user exists and the password is valid, else it returns False. ``username`` is the email if the "auth_user" table does not have a "username" field.

#### Auth Settings and messages

Here is a list of all parameters that can be customized for **Auth**

The following must point to a ``gluon.tools.Mail`` object to allow ``auth`` to send emails:

``
auth.settings.mailer = None
``:code

Read more about setting up mail here: [[Mail and Auth #mail_and_auth]]

The following must be the name of the controller that defined the ``user`` action:

``
auth.settings.controller = 'default'
``:code

The following was a very important setting in older web2py versions:

``
auth.settings.hmac_key = None
``:code

Where it was set to something like "sha512:a-pass-phrase" and passed to the CRYPT validator for the "password" field of the ``auth_user`` table, providing the algorithm and a-pass-phrase used to hash the passwords. However, web2py no longers needs this setting because it handles this automatically.

By default, auth also requires a minimum password length of 4. This can be changed:
``
auth.settings.password_min_length = 4
``:code

To disable an action append its name to this list:
``
auth.settings.actions_disabled = []
``:code

For example:

``
auth.settings.actions_disabled.append('register')
``:code

will disable registration.

If you want to receive an email to verify registration set this to ``True``:

``
auth.settings.registration_requires_verification = False
``:code

To automatically login people after registration, even if they have not completed the email verification process, set the following to ``True``:

``
auth.settings.login_after_registration = False
``:code

If new registrants must wait for approval before being able to login set this to ``True``:

``
auth.settings.registration_requires_approval = False
``:code

Approval consists of setting ``registration_key==''`` via appadmin or programmatically.

If you do not want a new group for each new user set the following to ``False``:

``
auth.settings.create_user_groups = True
``:code

The following settings determine alternative login methods and login forms, as discussed previously:

``
auth.settings.login_methods = [auth]
auth.settings.login_form = auth
``:code

Do you want to allow basic login?

``
auth.settings.allows_basic_login = False
``:code


The following is the URL of the ``login`` action:

``
auth.settings.login_url = URL('user', args='login')
``:code

If the user tried to access the register page but is already logged in, he will be redirected to this URL:

``
auth.settings.logged_url = URL('user', args='profile')
``:code

This must point to the URL of the download action, in case the profile contains images:

``
auth.settings.download_url = URL('download')
``:code

These must point to the URL you want to redirect your users to after the various possible ``auth`` actions (in case there is no referrer):

Note: If your app is based on the standard scaffold app Welcome, you use the auth.navbar. 
To get the settings below to take effect, you need to edit layout.html and set argument referrer_actions = None. 
auth.navbar(mode='dropdown',referrer_actions=None)

It is also possible to keep referrer_actions for some auth events. 
For example
``
auth.navbar(referrer_actions=['login', 'profile'])
``:code

If the default behavior is left unchanged, auth.navbar uses the _next URL parameter, and uses that to send the user back to the referring page.
However, if navbar's default auto-referring behavior is changed, the settings below will take effect.

``
auth.settings.login_next = URL('index')
auth.settings.logout_next = URL('index')
auth.settings.profile_next = URL('index')
auth.settings.register_next = URL('user', args='login')
auth.settings.retrieve_username_next = URL('index')
auth.settings.retrieve_password_next = URL('index')
auth.settings.change_password_next = URL('index')
auth.settings.request_reset_password_next = URL('user', args='login')
auth.settings.reset_password_next = URL('user', args='login')
auth.settings.verify_email_next = URL('user', args='login')
``:code

If the visitor is not logger in, and calls a function that requires authentication,
the user is redirected to ``auth.settings.login_url`` which defaults to ``URL('default','user/login')``.
One can replace this behavior by redefining:
``on_failed_authentication``:inxx

``
auth.settings.on_failed_authentication = lambda url: redirect(url)
``:code

This is the function called for the redirection. The argument ``url``` passed to this function is the url for the login page.

If the visitor does not have permission to access a given function, the visitor is redirect to the URL defined by
``on_failed_authorization``:inxx

``
auth.settings.on_failed_authorization = \
    URL('user',args='on_failed_authorization')
``:code

You can change this variable and redirect the user elsewhere.

Often ``on_failed_authorization`` is a URL but it can be a function that returns the URL and it will be called on failed authorization.

These are lists of callbacks that should be executed after form validation for each of the corresponding action before any database IO:

``
auth.settings.login_onvalidation = []
auth.settings.register_onvalidation = []
auth.settings.profile_onvalidation = []
auth.settings.retrieve_password_onvalidation = []
auth.settings.reset_password_onvalidation = []
``:code

Each callback must be a function that takes the ``form`` object and it can modify the attributes of the form object before database IO is performed.

These are lists of callbacks that should be executed after the database IO is performed and before redirection:

``
auth.settings.login_onaccept = []
auth.settings.register_onaccept = []
auth.settings.profile_onaccept = []
auth.settings.verify_email_onaccept = []
``:code

Here is an example:

``
auth.settings.register_onaccept.append(lambda form:\
   mail.send(to='you@example.com',subject='new user',
             message='new user email is %s'%form.vars.email))
``:code

You can enable captcha for any of the ``auth`` actions:

``
auth.settings.captcha = None
auth.settings.login_captcha = None
auth.settings.register_captcha = None
auth.settings.retrieve_username_captcha = None
auth.settings.retrieve_password_captcha = None
``:code

If the ``.captcha`` settings points to a ``gluon.tools.Recaptcha``, all forms for which the corresponding option (like ``.login_captcha``) is set to ``None`` will have a captcha, while those for which the corresponding option is set to ``False`` will not. If, instead, ``.captcha`` is set to ``None``, only those form who have a corresponding option set to a ``gluon.tools.Recaptcha`` object will have captcha and the others will not.

This is the login session expiration time:

``
auth.settings.expiration = 3600  # seconds
``:code

You can change the name of the password field (in Firebird for example "password" is a keyword and cannot be used to name a field):

``
auth.settings.password_field = 'password'
``:code


Normally the login form tries to validate an email. This can be disabled by changing this setting:

``
auth.settings.login_email_validate = True
``:code

Do you want to show the record id in the edit profile page?

``
auth.settings.showid = False
``:code

For custom forms you may want to disable automatic error notification in forms:

``
auth.settings.hideerror = False
``:code

Also for custom forms you can change the style:

``
auth.settings.formstyle = 'table3cols'
``:code

(it can be "table2cols", "divs" and "ul")

And you can set the separator for auth-generated forms:

``
auth.settings.label_separator =        ':'
``:code


By default the login form gives the option to extend the login via "remember me" option. The expiration time can be changed or the option disabled via these settings:

``
auth.settings.long_expiration = 3600*24*30 # one month
auth.settings.remember_me_form = True
``:code

You can also customize the following messages whose use and context should be obvious:
``
auth.messages.submit_button = 'Submit'
auth.messages.verify_password = 'Verify Password'
auth.messages.delete_label = 'Check to delete:'
auth.messages.function_disabled = 'Function disabled'
auth.messages.access_denied = 'Insufficient privileges'
auth.messages.registration_verifying = 'Registration needs verification'
auth.messages.registration_pending = 'Registration is pending approval'
auth.messages.login_disabled = 'Login disabled by administrator'
auth.messages.logged_in = 'Logged in'
auth.messages.email_sent = 'Email sent'
auth.messages.unable_to_send_email = 'Unable to send email'
auth.messages.email_verified = 'Email verified'
auth.messages.logged_out = 'Logged out'
auth.messages.registration_successful = 'Registration successful'
auth.messages.invalid_email = 'Invalid email'
auth.messages.unable_send_email = 'Unable to send email'
auth.messages.invalid_login = 'Invalid login'
auth.messages.invalid_user = 'Invalid user'
auth.messages.is_empty = "Cannot be empty"
auth.messages.mismatched_password = "Password fields don't match"
auth.messages.verify_email = ...
auth.messages.verify_email_subject = 'Password verify'
auth.messages.username_sent = 'Your username was emailed to you'
auth.messages.new_password_sent = 'A new password was emailed to you'
auth.messages.password_changed = 'Password changed'
auth.messages.retrieve_username = 'Your username is: %(username)s'
auth.messages.retrieve_username_subject = 'Username retrieve'
auth.messages.retrieve_password = 'Your password is: %(password)s'
auth.messages.retrieve_password_subject = 'Password retrieve'
auth.messages.reset_password = ...
auth.messages.reset_password_subject = 'Password reset'
auth.messages.invalid_reset_password = 'Invalid reset password'
auth.messages.profile_updated = 'Profile updated'
auth.messages.new_password = 'New password'
auth.messages.old_password = 'Old password'
auth.messages.group_description = \
    'Group uniquely assigned to user %(id)s'
auth.messages.register_log = 'User %(id)s Registered'
auth.messages.login_log = 'User %(id)s Logged-in'
auth.messages.logout_log = 'User %(id)s Logged-out'
auth.messages.profile_log = 'User %(id)s Profile updated'
auth.messages.verify_email_log = 'User %(id)s Verification email sent'
auth.messages.retrieve_username_log = 'User %(id)s Username retrieved'
auth.messages.retrieve_password_log = 'User %(id)s Password retrieved'
auth.messages.reset_password_log = 'User %(id)s Password reset'
auth.messages.change_password_log = 'User %(id)s Password changed'
auth.messages.add_group_log = 'Group %(group_id)s created'
auth.messages.del_group_log = 'Group %(group_id)s deleted'
auth.messages.add_membership_log = None
auth.messages.del_membership_log = None
auth.messages.has_membership_log = None
auth.messages.add_permission_log = None
auth.messages.del_permission_log = None
auth.messages.has_permission_log = None
auth.messages.label_first_name = 'First name'
auth.messages.label_last_name = 'Last name'
auth.messages.label_username = 'Username'
auth.messages.label_email = 'E-mail'
auth.messages.label_password = 'Password'
auth.messages.label_registration_key = 'Registration key'
auth.messages.label_reset_password_key = 'Reset Password key'
auth.messages.label_registration_id = 'Registration identifier'
auth.messages.label_role = 'Role'
auth.messages.label_description = 'Description'
auth.messages.label_user_id = 'User ID'
auth.messages.label_group_id = 'Group ID'
auth.messages.label_name = 'Name'
auth.messages.label_table_name = 'Table name'
auth.messages.label_record_id = 'Record ID'
auth.messages.label_time_stamp = 'Timestamp'
auth.messages.label_client_ip = 'Client IP'
auth.messages.label_origin = 'Origin'
auth.messages.label_remember_me = "Remember me (for 30 days)"
``:code
``add|del|has`` membership logs allow the use of "%(user_id)s" and "%(group_id)s".
``add|del|has`` permission logs allow the use of "%(user_id)s", "%(name)s", "%(table_name)s", and "%(record_id)s".

### Central Authentication Service
``CAS``:inxx ``authentication``:inxx

web2py provides support for third party authentication and single sign on.
Here we discuss the Central Authentication Service (CAS) which is an industry standard and both client and server are built-into web2py.

CAS is an open protocol for distributed authentication and it works in the following way: When a visitor arrives at our web site, our application check in the session if the user is already authenticated (for example via a ``session.token`` object). If the user is not authenticated, the controller redirects the visitor from the CAS appliance, where the user can log in, register, and manage his credentials (name, email and password). If the user registers, he receives an email, and registration is not complete until he responds to the email. Once the user has successfully registered and logged in, the CAS appliance redirects the user to our application together with a key. Our application uses the key to get the credentials of the user via an HTTP request in the background to the CAS server.

Using this mechanism, multiple applications can use a single sign-on via a single CAS server. The server providing authentication is called a service provider. Applications seeking to authenticate visitors are called service consumers.

CAS is similar to OpenID, with one main difference. In the case of OpenID, the visitor chooses the service provider. In the case of CAS, our application makes this choice, making CAS more secure.

Running a web2py CAS provider is as easy as copying the scaffolding app. In fact any web2py app that exposes the action

``
## in provider app
def user(): return dict(form=auth())
``

is a CAS 2.0 provider and its services can be accessed at the URL

``
http://.../provider/default/user/cas/login
http://.../provider/default/user/cas/validate
http://.../provider/default/user/cas/logout
``:code
(we assume the app to be called "provider").

You can access this service from any other web application (the consumer) by simply delegating authentication to the provider:

``
## in consumer app
auth = Auth(db,cas_provider = 'http://127.0.0.1:8000/provider/default/user/cas')
``:code

When you visit the login url the consumer app, it will redirect you to the provider app which will perform authentication and will redirect back to the consumer. All processes of registration, logout, change password, retrieve password, have to be completed on the provider app. An entry about the logged-in user will be created on the consumer side so that you add extra fields and have a local profile. Thanks to CAS 2.0 all fields that are readable on the provider and have a corresponding field in the ``auth_user`` table of the consumer will be copied automatically.

``Auth(...,cas_provider='...')`` works with third party providers and supports CAS 1.0 and 2.0. The version is detected automatically. By default it builds the URLs of the provider from a base (the ``cas_provider`` url above) by appending

``
/login
/validate
/logout
``:code

These can be changed in consumer and in provider

``
## in consumer or provider app (must match)
auth.settings.cas_actions['login']='login'
auth.settings.cas_actions['validate']='validate'
auth.settings.cas_actions['logout']='logout'
``

If you want to connect to a web2py CAS provider from a different domain, you must enable them by appending to the list of allowed domains:

``
## in provider app
auth.settings.cas_domains.append('example.com')
``:code


#### Using web2py to authorize non-web2py apps

This is possible but dependent on the web server.
here we assume two applications running under the same web server: Apache with ``mod_wsgi``.
One of the applications is web2py with an app proving access control via Auth.
The other can be a CGI script, a PHP program or anything else.
We want to instruct the web server to ask permission to the former application when a client requests access to the latter.

First of all we need to modify the web2py application and add the following controller:

``
def check_access():
    return 'true' if auth.is_logged_in() else 'false'
``:code

which returns ``true`` if the user is logged in and ``false`` otherwise. Now run a web2py process in background:

``
nohup python web2py.py -a '' -p 8002
``

Port 8002 is a must and there is no need to enable admin so no admin password.

Then we need to edit the Apache config file (for example "/etc/apache2/sites-available/default") and instruct apache so that when the non-web2py program is called, it should call the above ``check`` action instead and only if it returns ``true`` it should proceed and respond to the request, else if should deny access.

Because web2py and the non-web2py application run under the same domain, if the user is logged into the web2py app, the web2py session cookie will be passed to Apache even when the other app is requested and will allow credential verification.

In order to achieve this we need a script, "web2py/scripts/access.wsgi" that can play this trick.
The script ships with web2py. All we need to do it tell apache to call this script, the URL of the application needing access control, and the location of the script:

``
<VirtualHost *:80>
   WSGIDaemonProcess web2py user=www-data group=www-data
   WSGIProcessGroup web2py
   WSGIScriptAlias / /home/www-data/web2py/wsgihandler.py

   AliasMatch ^myapp/path/needing/authentication/myfile /path/to/myfile
   <Directory /path/to/>
     WSGIAccessScript /path/to/web2py/scripts/access.wsgi
   </Directory>
</VirtualHost>
``

Here "^myapp/path/needing/authentication/myfile" is the regular expression that should match the incoming request and "/path/to/" is the absolute location of the web2py folder.

The "access.wsgi" script contains the following line:

``
URL_CHECK_ACCESS = 'http://127.0.0.1:8002/%(app)s/default/check_access'
``

which points to the web2py application we have requested but you can edit it to point to a specific application, running on a port other than 8002.

You can also change the ``check_access()`` action and make its logic more complex. This action can retrieve the URL that was originally requested using the environment variable

``
request.env.request_uri
``

and you can implement more complex rules:

``
def check_access():
    if not auth.is_logged_in():
       return 'false'
    elif not user_has_access(request.env.request_uri):
       return 'false'
    else:
       return 'true'
``:code
